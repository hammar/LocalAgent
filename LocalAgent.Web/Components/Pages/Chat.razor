@page "/"
@rendermode InteractiveServer
@using LocalAgent.ApiService.Models
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.Extensions.AI
@inject IConfiguration Configuration
@inject IHttpClientFactory HttpClientFactory

<h3>Chat Bot</h3>

<!-- Agent selection dropdown -->
<div style="margin-bottom: 16px;">
    <label for="agentSelect" style="margin-right: 8px;">Select Agent:</label>
    <select id="agentSelect" value="@SelectedAgentId" @onchange="OnAgentChanged" style="padding: 4px 8px;">
        @foreach (var agent in AllAgents)
        {
            <option value="@agent.Id">@agent.Id</option>
        }
    </select>
</div>

<div class="chat-main-container" style="display:flex;gap:24px;max-width:1200px;margin:auto;">
    <!-- Chat Window (Left) -->
    <div class="chat-container" style="flex:1;min-width:0;">
        <div class="messages" style="border:1px solid #ccc;padding:10px;height:300px;overflow-y:auto;">
            @if (_chatHistory.Count == 0)
            {
                <p><em>No messages yet.</em></p>
            }
            else
            {
                foreach (var chatMessage in _chatHistory.Where(msg => !string.IsNullOrEmpty(msg.Text)))
                {
                    <div class="message" style="margin-bottom:8px;">
                        <strong style="text-transform: capitalize;">@chatMessage.Role:</strong> @chatMessage.Text
                    </div>
                }
            }
            @if (!string.IsNullOrEmpty(_streamingResponse)) {
                <div class="message">
                    <strong>Assistant:</strong> @_streamingResponse
                </div>
            }
        </div>
        <div class="input-group" style="margin-top:10px;display:flex;">
            <input type="text" placeholder="Enter your message..."
                   @bind="UserPrompt"
                   @bind:event="oninput"
                   @onkeydown="HandleKeyDown"
                   disabled="@SendDisabled"
                   class="chat-input"
                   style="flex:1;padding:8px;border:1px solid #ccc;"/>
            <button @onclick="SendMessage"
                    disabled="@SendDisabled"
                    class="send-button"
                    style="padding:8px 16px;margin-left:5px;">Send</button>
        </div>
    </div>
    <!-- Actions Window (Right) -->
    <div class="actions-container" style="flex:1;min-width:0;border:1px solid #ccc;padding:10px;height:370px;overflow-y:auto;background:#fafbfc;">
        <h4>Actions Taken by the Chatbot</h4>
        @if (Actions.Count == 0)
        {
            <p><em>No actions yet.</em></p>
        }
        else
        {
            <ul style="padding-left:18px;">
                @foreach (var action in Actions)
                {
                    <li style="margin-bottom:8px;">@action</li>
                }
            </ul>
        }
        <!-- Later, populate this with actual actions from the chatbot -->
    </div>
</div>

@code {
    private HubConnection _hubConnection = default!;

    private bool SendDisabled = false;
    private List<ChatMessage> _chatHistory = [];
    
    private Dictionary<string,List<ChatResponseUpdate>> _responseUpdatesBuffer = new ();

    private string _streamingResponse = string.Empty;

    private List<string> Actions = new();

    private string UserPrompt { get; set; } = string.Empty;
    private List<Agent> AllAgents = new();

    private HttpClient Http => HttpClientFactory.CreateClient("DefaultClient");

    private Guid? SelectedAgentId { get; set; }

    /// <summary>
    /// Initialize the SignalR connection when the component is loaded.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        SendDisabled = true;
        AllAgents = await Http.GetFromJsonAsync<List<Agent>>("api/agents") ?? new();
        if (AllAgents.Count > 0 && SelectedAgentId == null)
        {
            SelectedAgentId = AllAgents[0].Id;
        }

        var backendUrl = Configuration["services:apiservice:https:0"];
        if (string.IsNullOrWhiteSpace(backendUrl))
        {
            throw new InvalidOperationException("Backend URL is not configured.");
        }

        // Build the hub connection using the absolute URL.
        _hubConnection = new HubConnectionBuilder()
            .WithUrl($"{backendUrl}/chathub")
            .Build();

        // Subscribe to the "ReceiveMessage" event from the hub.
        _hubConnection.On<ChatResponseUpdate>("ProcessAgentResponse", async (responseUpdate) =>
        {
            // A response ID is required in order to reconstruct responses from partial updates.
            ArgumentException.ThrowIfNullOrEmpty(responseUpdate.ResponseId, nameof(responseUpdate.ResponseId));

            // Add the response update to the buffer (creating a new list if this is the first update for a given response).
            // This buffer holds all the updates for a given response until the response is completely retrieved.
            if (_responseUpdatesBuffer.TryGetValue(responseUpdate.ResponseId, out var responseUpdates) && responseUpdates != null) {
                responseUpdates.Add(responseUpdate);
            }
            else {
                responseUpdates = new List<ChatResponseUpdate> { responseUpdate };
                _responseUpdatesBuffer[responseUpdate.ResponseId] = responseUpdates;
            }

            // If this is the last update to the response then we can now create a message from the buffer
            // and add it to the chat or action history, and the GUI will include it on next re-render.
            if (responseUpdate.FinishReason.HasValue) {
                // TODO: figure out what happens with error responses and other non-text but non-action responses.
                var completeResponse = responseUpdates.ToChatResponse();
                if (!string.IsNullOrEmpty(completeResponse.Text)) {
                    // This is a text response from the agent, so we add it to the chat history.
                    _chatHistory.AddMessages(responseUpdates);
                    _streamingResponse = string.Empty; // Clear the streaming GUI after message completion to avoid duplicate text.
                    SendDisabled = false; // Re-enable the input field.
                }
                else {
                    // This response is an action taken by the agent, so we add any steps from it to the actions list.
                    Actions.AddRange(GetActionDescriptions(completeResponse));
                }
                
                _responseUpdatesBuffer.Remove(responseUpdate.ResponseId); // Since the response is complete, we can remove it from the buffer.
                
            }
            else if (!string.IsNullOrEmpty(responseUpdate.Text)) {
                // Otherwise, if the response is not yet completely received, then we we stream the
                // partial response to the UI directly for a nice UX -- but only for text content!
                _streamingResponse += responseUpdate.Text;
            }

            await InvokeAsync(StateHasChanged);
        });

        // Start the SignalR connection.
        await _hubConnection.StartAsync();

        // Call StartAgent after SignalR connection is established and agent is selected
        if (SelectedAgentId.HasValue)
        {
            await StartAgent();
        }
    }

    private static IEnumerable<string> GetActionDescriptions(ChatResponse response) 
    {
        foreach (var content in response.Messages.SelectMany(msg => msg.Contents))
        {
            // TODO: Add more content types here as needed.
            if (content is FunctionCallContent functionCall)
            {
                yield return $"Function Call: {functionCall.Name}({string.Join(", ", functionCall.Arguments?.Select(arg => $"{arg.Key}: {arg.Value}") ?? [])})";
            }
            else if (content is FunctionResultContent functionResult)
            {
                yield return $"Function Result: {functionResult.Result}";
            }
        }
    }

    /// <summary>
    /// Sends the user message to the SignalR hub.
    /// </summary>
    private async Task SendMessage()
    {
        if (!SendDisabled && !string.IsNullOrWhiteSpace(UserPrompt) && SelectedAgentId.HasValue)
        {
            _chatHistory.Add(new(ChatRole.User, UserPrompt));
            await _hubConnection.SendAsync("ProcessUserPrompt", SelectedAgentId.Value, _chatHistory);
            UserPrompt = string.Empty;
            SendDisabled = true; // Disable the input field while waiting for a response.
        }
    }

    /// <summary>
    /// Listens for the Enter key in the input field to send a message.
    /// </summary>
    /// <param name="e">Keyboard event arguments</param>
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendMessage();
        }
    }

    private async Task OnAgentChanged(ChangeEventArgs e)
    {
        if (Guid.TryParse(e.Value?.ToString(), out var agentId))
        {
            SelectedAgentId = agentId;
            await StartAgent();
        }
    }

    private async Task StartAgent()
    {
        if (!SelectedAgentId.HasValue) return;
        
        _chatHistory.Clear();
        SendDisabled = true;
        await _hubConnection.SendAsync("StartAgent", SelectedAgentId.Value);
    }

    /// <summary>
    /// Dispose the SignalR connection when the component is disposed.
    /// </summary>
    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }
}